
---

# Lab Environment

Two machines are accessible at **target1.ine.local** and **target2.ine.local**. Enumerate the targets, identify and exploit the misconfigurations or vulnerabilities to capture the flags. The flag is in an md5 hash format.

- **Flag 1:** A vulnerable service maybe running on **target1.ine.local**. If exploitable, retrieve the flag from the root directory.
- **Flag 2:** Further, a quick interaction with a local network service on **target1.ine.local** may reveal this flag. Use the hint given in the previous flag.
- **Flag 3:** A misconfigured service running on **target2.ine.local** may help you gain access to the machine. Can you retrieve the flag from the root directory?
- **Flag 4:** Can you escalate to root on **target2.ine.local** and read the flag from the restricted /root directory?

# Tools

- Metasploit
- Nmap
- Python3
- Netcat
- smbmap
- smbclient
- Netstat

---


### First Target

We will start with our Nmap scan: `nmap -Pn nmap -Pn -A -v target1.ine.local`

We find two open ports: 21/proftpd 1.3.5, and 80/Apache 2.4.41

We don't get so much when we run Wmap against the website, so we will target the FTP service.

We will search for the version of the ftp service on MSF: `search proftpd 1.3.5`

We find one exploit module that can give us a reverse shell: "unix/ftp/proftpd_modcopy_exec"

We need to change the: "SITEPATH" option to: "/var/www/html" because this is where Apache website files are based.

If we ran the module, we will get a reverse shell on the target machine.

The first target can be found in:"/" directory along side with a hint to find the next flag.

**First flag:** 771f8cecf8c34c8bb13e90abe3c2760c

----

We also find this with the first flag: Remember, the magical word is 'letmein'

To find the second flag, we will need to list all of the services running on open ports on the target machine: `netstat -tuln`

We will get these open ports: 127.0.0.1:8888, 127.0.0.11:37527,  0.0.0.0:80, 0.0.0.0:21, and 127.0.0.11:60396

We will try to grab their banners using netcat: `nc -nv (IP) (port)`

We will get a password prompt when we try to connect to: "127.0.0.1:8888"

If we tried the password we got from the first flag file, we will get the second flag.

**Second flag:** 4ba6dbb75de246a39ff795b84358ad45

---

### Second Target 

We will start with our Nmap scan: `nmap -Pn nmap -Pn -A -v target2.ine.local`

We will get three open ports: 80/Apache 2.4.41, 139 and 445 running Samba 4.6.2

We will try to brute-force into Samba service.

We will get multiple valid credentials that we can use to login to the smb service.

Using: "scanner/smb/smb_login" MSF module, we will create multiple sessions on the smb service.

We will list the shares available: `shares`. One share looks interesting: "site-uploads"

We will interact with it: `shares -i site-uploads`

We will try to upload a text file and see if we can access it on the website. 

After we create a text file using any text editor, we will upload it by using: `upload (name of text file)`

We will try to see the file on a web browser by: `http://target2.ine.local/site-uploads/(name of text file)`. We indeed can see the content of the text file we uploaded. 

Since we can upload any file we want, we will upload a reverse shell file written in PHP. 

Kali already comes with reverse shells scripts. 

We can find the one we want on our local machine in : "/usr/share/webshells/php" directory and the script file called: "php-reverse-shell.php "

We only need to change the ip value from :"127.0.0.1" to our IP address.

We will upload the file and we will have Netcat listening to the port specified in the script we uploaded which should be: "1234" by default.

On a cmd window on our local machine: `nc -nvlp 1234`

We will execute the file that we uploaded the same way we viewed the content of the text file we uploaded.

If we returned back to the Netcat window, we will have a reverse shell.

The third flag can be found in: "/" directory.

**Third flag:** f872b8d7e6be4abc8cab0477221a6d95

---

The forth flag is very confusing and I had to look up the solution.

We will list the shells on the target machine: `ls /etc/shells`. We will get these:
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash

We will check each shell permission: `cat /etc/shells | while read shell; do ls -l $shell 2>/dev/null/; done`

The command `cat /etc/shells | while read shell; do ls -l $shell 2>/dev/null; done` reads each shell listed in `/etc/shells`, checks its permissions using `ls -l`, and suppresses any errors (e.g., inaccessible files) with `2>/dev/null`.

We can use any shell with these permissions: "lrwxrwxrwx" which we have two of them: "/bin/rbash" and "/usr/bin/rbash"

We will run this command to gain root privileges: `find / -exec /bin/rbash -p \; -quit`

The command `find / -exec /bin/rbash -p \; -quit` searches the entire filesystem (`/`) for files and, for each file it finds, attempts to execute the restricted shell (`/bin/rbash`) with the `-p` option, which enables the restricted shell's behavior. The `-quit` flag causes `find` to stop searching after the first file is found and processed. In essence, it runs `/bin/rbash` on the first file it encounters, which could result in privilege escalation if the file has setuid (set user ID) permissions or is a root-owned executable. This command could inadvertently execute a root-level command or script, potentially granting root privileges, depending on the files it encounters.

The shell we got can't change directory.

We will view the content of the forth flag file: `cat /root/flag4.txt`

**Forth flag:** 46f0099fac744d9c9296934d8035a1cc